# 给人看的：OpenClaw 作为主 Agent 的“调度系统”，如何带着一群 Claude Code 干活

这篇不是教程，不要求你照着折腾。它讲三件事：
1) 为什么需要 **主 Agent（OpenClaw）**
2) 为什么 **tmux** 是并行 AI 工作流的“结构件”
3) 这种方式的“质变”到底是什么

## 1. 问题不在模型，而在并行时代的人类注意力
当你同时推进 5~10 件事（改 UI、修 bug、写脚本、排查构建），传统方式会自然退化成：
- 多个 IDE 窗口 + 多个终端 tab + 多个 AI 对话窗口
- 你在脑子里维护一张“窗口 ↔ 任务”的映射表

真正的瓶颈不是 AI 不够聪明，而是：
- **不可调度**：必须坐在电脑前才能发起
- **不可观测**：你不知道哪个任务卡住了
- **不可接管**：卡住时先找窗口，再补上下文
- **不可复盘**：做完只剩一句 done，没有证据链

## 2. OpenClaw 的角色：管家 + CTO（主 Agent / 调度层）
在这套体系里，OpenClaw 不是“又一个写代码的 agent”。它更像：
- **管家**：接收任务、排队、分配执行节点、收集交付物
- **CTO**：强制工程化约束（质量门、报告、回调），把“聊天式能力”变成“可审计作业”

一句话：
> **主 Agent 负责把任务变成 Job；子 Agent 负责把 Job 做完。**

## 3. Claude Code 的角色：执行引擎（子 Agent / 执行层）
Claude Code 的优势是“在 repo 里动手”：
- 读代码、改代码、跑命令、修报错

但它不天然解决“并行管理”。当你同时跑 6 个 Claude Code，真正需要的是：
- 给每个任务一个隔离空间
- 给每个任务一个可观察的日志
- 给每个任务一个可回收的交付物

## 4. tmux 的角色：把任务从‘窗口’升级为‘会话/作业’（可观测 + 可接管）
tmux 的价值非常朴素：
- 每个任务一个 session：`cc-<label>`
- **随时 attach** 看输出
- 卡住了直接接管键盘

这就把“并行”从 UI 层（开很多窗口）推进到了系统层（管理一组作业）。

## 5. 质变点：从管理窗口到管理作业
这套组合带来的质变，本质是结构变化：
- 窗口 → job
- 口头 done → 报告（diff/lint/build/risk）
- 走回工位才开始 → 手机上也能发起

**你不再管理窗口，你开始管理作业。**

## 6. 如何使用这个仓库
- 如果你是人类读者：看 `docs/` 里的 4 篇分享稿 + 本文即可。
- 如果你是要“让 agent 直接跑”：把 `AGENT_RUNBOOK.md` 作为参考文档丢给 OpenClaw/Claude 即可。

> 这个仓库的设计目标：**给人看的是意义与方式变化；给 agent 看的是可执行步骤。**
