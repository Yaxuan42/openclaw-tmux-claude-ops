# FINAL｜OpenClaw × Claude Code × tmux：把并行 AI 执行变成“可调度作业系统”

> 这是一份融合 4 个版本优点的最终版：既讲清楚“为什么是质变”，也给出足够落地的框架。
> 
> **一句话主轴：你不再管理窗口，你开始管理作业。**

---

## 1. 背景：瓶颈不在模型，而在并行时代的人类注意力
当你同时推进 5~10 件事（修 bug、改 UI、写文档、跑脚本、排查构建），传统工作方式会自然退化成：
- 多个 IDE 窗口 + 多个终端 tab + 多个 AI 对话窗口
- 你在脑子里维护一张“窗口 ↔ 任务”的映射表

真正的痛点不是“乱”，而是四个结构性缺陷：
- **不可调度**：任务发起依赖“人坐在电脑前”
- **不可观测**：哪个任务卡住、卡在哪一步不可见
- **不可接管**：卡住时先找窗口、再补上下文、再介入
- **不可复盘**：结束只剩一句 done，没有证据链

这些问题不会因为模型更聪明而自动消失——它们属于工作流结构。

---

## 2. 角色分工：三层架构（主 Agent / 子 Agent / 可观测层）

### 2.1 主 Agent：OpenClaw（管家 + CTO）
OpenClaw 在这里不是“又一个写代码的 agent”，而是调度系统：
- **管家**：接收任务（手机/Telegram）、排队/分配执行节点、收集交付物
- **CTO**：把工程化约束写进流程（质量门、报告、回调），把聊天式能力变成可审计作业

主 Agent 负责把一句话变成一个 Job：
- 生成结构化 prompt（含交付协议、约束、回调）
- 启动 tmux session（默认单机即可；多设备/远程属于进阶用法）
- 等待回调 → 读取报告 → 给出下一步判断（是否合并/是否回滚/是否人工介入）

### 2.2 子 Agent：Claude Code（执行引擎）
Claude Code 负责在 repo 内“真正动手”：读代码、改代码、跑命令、写交付报告。

### 2.3 tmux：可观测 + 可接管层
tmux 让每个任务变成一个“后台会话/作业”：
- 每个任务一个 session（如 `cc-<label>`）
- **随时 attach** 看实时输出
- 卡住时直接接管键盘继续处理

tmux 的 stdout 就是最朴素的 observability：不需要额外协议。

---

## 3. 为什么说是“质变”：从管理窗口到管理作业
这不是“AI 更聪明”的质变，而是结构变化：

| 维度 | 以前（多窗口） | 现在（Job 模式） |
|---|---|---|
| 发起 | 坐在电脑前开环境 | 手机发一句话，主 Agent 调度 |
| 观测 | 猜进度/翻窗口 | `tmux attach` / monitor 直接看输出 |
| 接管 | 停掉重开、重述上下文 | attach 进去当场接管 |
| 交付 | 一句 done | 报告（changedFiles/diff/lint/build/risk） |
| 复盘 | 翻聊天记录 | 读 report + 需要时回看 tmux scrollback |

你会明显感觉：并行推进时注意力不再被“现场管理”吞噬。

---

## 4. 强制交付协议：把“done”变成可审计交付物
建议每个任务结束前强制完成三阶段：

1) **质量门**（至少）：
- `git status --short`
- `git diff --name-only`
- `git diff --stat`
- `npm run lint`（或等价质量检查）
- `npm run build`（或等价构建检查）

2) **产出报告**（JSON + Markdown）：
- `/tmp/cc-<label>-completion-report.json`
- `/tmp/cc-<label>-completion-report.md`

3) **最后才允许回调**（wake）：
- wake 是“交付触发器”，不是交付本身

这一步的意义是：你收到的不是“相信我”，而是“证据链”。

---

## 5. 适用与不适用

适合：
- 并行 3 件以上的工程任务（UI polish、文档整理、低风险重构、脚本编写）
- 需要随时接管（构建/依赖/权限/环境容易出幺蛾子）
- 需要可审计交付（协作/评审/可回滚）

不适合：
- 强依赖人类判断的产品决策
- 超长时间无人值守且高风险的自动改动（应拆成更小 job）
- 高频探索性调试（直接 IDE 更顺手）

---

## 6. 安全与边界（必须说清）
这套方案的默认形态是**单机编排**：OpenClaw、tmux、Claude Code 在一台机器上即可跑出质变。

如果你引入**远程/多设备执行**（进阶），本质会升级为“远程代码执行能力”，最低要求：
- SSH key 最小权限
- 必要时在 `authorized_keys` 中用 `command=` 限制回调可执行范围

无论单机还是多机：
- 所有改动放在 git 管控下，保证可回滚

---

## 7. 可直接照抄的 3 条实践建议
1) **任务=一个 tmux session + 一个 label**：从命名开始建立“作业感”。
2) **把交付协议写进 prompt**：diff/lint/build + 报告路径，别靠口头。
3) **先读报告再读 diff**：低风险快速合，高风险再 attach 追溯过程。
