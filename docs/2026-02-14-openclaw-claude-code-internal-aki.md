# 用 OpenClaw（Codex 5.3）在手机上调度一堆 Claude Code：从「开很多窗口」到「像调度系统」

> 适用场景：你同时推进多个代码/文档/排查任务；希望随时可见、可接管、可复盘；又不想被一堆 IDE/终端窗口淹没。

## 0. TL;DR（给忙人）
- **质变点**不是“又能跑一个 agent”，而是把任务执行从「手动开窗口」升级为「**调度 + 可观测 + 可接管**」。
- OpenClaw 负责：**接收任务（手机也行）→ 生成稳定 prompt → 起 tmux 会话 → 推 Claude Code 跑 → 完成后回调/产出报告**。
- Claude Code 负责：在具体 repo 里干活。
- tmux 负责：**把每个任务变成可随时 attach 的“后台作业”**（比开十个窗口更接近“系统化工作流”）。

## 1. 我们原来的痛点是什么
在高并发任务（多分支、多模块、多项目）里，传统工作方式通常是：
- 需要并行推进 3~10 个小任务：修 bug、改 UI、写文档、跑脚本、排查构建。
- 于是开：
  - N 个 VS Code 窗口
  - N 个终端 tab
  - N 个 Claude 聊天窗口/网页
- 结果是：
  - **上下文切换成本高**（每个窗口都要重新“回忆”）
  - **不可观测**（哪个任务卡住了？卡在哪一步？）
  - **不可接管**（卡住时你需要先找到那个窗口/终端）
  - **不可复盘**（做了什么、改了哪些、风险是什么，信息散落）

## 2. 新工作流：OpenClaw × Claude Code × tmux 的分工
把系统拆成三层，会清晰很多：

### 2.1 调度层（OpenClaw / Codex 5.3）
负责“把任务变成可运行的作业（job）”。
- 从手机/Telegram 发一句话：
  - “把 xxx 页面按钮状态统一成设计系统 + 加载态”
- OpenClaw 做：
  - 生成结构化指令（含交付协议、约束、回调）
  - 选择执行节点（本机/远程）
  - 启动 tmux 会话、注入 prompt
  - 任务完成后通知并附带报告地址

### 2.2 执行层（Claude Code）
负责“真正动手”。
- 在 repo 里：读代码、改代码、跑 lint/build、写总结报告。

### 2.3 可观测/可接管层（tmux）
负责“让每个任务变成可管理的后台会话”。
- 每个任务一个 tmux session：
  - **随时 attach 看实时输出**
  - 卡住了：你可以直接接管输入、修复、继续
  - 不需要让 IDE 窗口永远开着

## 3. 体验上的“质变”到底是什么
我觉得它像从「手工开厨房炉灶」变成「有工单系统的后厨」。

### 3.1 从“窗口”到“作业（Job）”
- 以前：我记得“哪个窗口在跑什么”。
- 现在：我记得“这个 label 的 job 在跑什么”。

### 3.2 从“猜进度”到“看得见”
- tmux 的输出就是最朴素的 observability：
  - 什么时候开始跑、在哪里卡住、报错是什么

### 3.3 从“任务结束=聊天说 done”到“任务结束=可审计报告”
我们在 orchestrator 里强制：
- `git status/diff`、`lint/build` 结果必须写入 `/tmp/...completion-report.json|md`
- 最后才允许 wake 通知

结果是：你不会收到“done”但不知道做了啥。

### 3.4 从“只能在电脑前”到“手机也能调度”
真正舒服的是：
- 你在路上/会议间隙也能发起任务
- 回来时直接看报告、看 diff、决定是否合并

## 4. 推荐的落地规范（团队可复用）

### 4.1 任务命名（label）
- `cc-<label>`：比如 `cc-billing-fix-rounding`
- label 里不要放空格，便于脚本与检索

### 4.2 强制交付协议（建议默认）
- `git status --short`
- `git diff --name-only`
- `git diff --stat`
- `npm run lint`
- `npm run build`
- 输出：
  - `/tmp/cc-<label>-completion-report.json`
  - `/tmp/cc-<label>-completion-report.md`

### 4.3 什么时候该用它
特别适合：
- 多个小任务并行：UI polish、脚手架迁移、文档整理、低风险 refactor
- 需要随时接管：构建/依赖/权限/环境容易出幺蛾子
- 需要可审计交付：团队协作/代码评审

不适合：
- 强依赖人类判断的产品决策
- 超长时间无人值守且高风险的自动改动（应该拆分成更小 job）

## 5. 风险与边界（必须说清）
- 这是“远程代码执行”的能力，一定要：
  - 限制 SSH key 权限
  - 限制回调命令（必要时 command= 限定）
  - 对 repo/目录做隔离
- 任何自动化都必须保留：
  - **可观测**（输出可见）
  - **可接管**（能人工介入）
  - **可回滚**（git）

## 6. 结语
我现在更愿意把它称为：
> 用 OpenClaw 把 Claude Code 从“聊天窗口里的能力”，变成“可调度、可观测、可接管的工程作业系统”。

如果要一句话总结质变：
**你不再管理窗口，你开始管理作业。**

---

## 可直接照抄的 3 条实践建议
1) **每个任务一个 label + 一个 tmux session**：从命名开始建立“作业感”。
2) **把交付协议写进 prompt**：diff/lint/build + 报告文件路径，别靠口头。
3) **先读报告再读 diff**：低风险快速合，高风险再 attach 追溯过程。
